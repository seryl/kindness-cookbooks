" .vimrc
"
" Generated by Chef for <%= node[:fqdn] %>
" Local modifications will be overwritten.

" To set Vim as your default editor and page add the following to your .bashrc
" and/or .profile startup files.
"export EDITOR=vim
"export VISUAL=vim
"export PAGER="/bin/sh -c \"unset PAGER;col -b -x | view -c 'set ft=man nomod
"nolist' -c 'map q :q<CR>' -c 'map <SPACE> <C-D>' -c 'map b <C-U>' -c 'nmap K
":Man <C-R>=expand(\\\"<cword>\\\")<CR><CR>' -\""

" Unset PAGER environment variable. This works with the PAGER setting in
" .profile or .bashrc. Avoids recursive Vim execs when using Vim's Man command.
let $PAGER=''

set nocompatible " use vim defaults (this should be first in .vimrc)
filetype indent on " load indent.vim

set history=1000 " number of commands and search patterns to save
set binary " show control characters (ignore 'fileformat')
"set noautoindent " do not auto indent
set shiftround " align to standard indent when shifting with < and >
set formatoptions+=r " auto-format comments while typing
" Note, t_Co=16 is good on OSX, but not on Linux (leave unset for default)
"set t_Co=16 " assume we have more colors to work with for highlighting
set background=dark " set terminal background

syntax on " use syntax color highlighting
set visualbell t_vb= " no beep or flash
set ttyfast " smoother display on fast network connections
set whichwrap=b,s,<,>,[,],~ " allow most motion keys to wrap
set backspace=indent,eol,start " allow bs over EOL, indent, and start of insert
set nostartofline " if possible, keep cursor in same column for many commands
set incsearch " incremental search
set ignorecase " ignore case when searching (see smartcase)
set smartcase " do not ignore case if pattern has mixed case (see ignorecase)
set nojoinspaces " use only one space when using join
set matchpairs+=<:> " add < > to chars that form pairs (see % command)
set showmatch " show matching brackets by flickering cursor
set matchtime=1 " show matching brackets quicker than default
set modeline " docs say this is default, but not on any Vim I tried!
set autoread " automatically read file changed outside of Vim
set autowrite " automatically save before commands like :next and :make
set splitbelow " open new split windows below the current one
set winminheight=0 " This makes more sense than the default of 1
set noequalalways " do not resize windows on split/close
"set shortmess="" " long messages -- does not seem to work
set showcmd " show partial command in status line
set suffixes+=.class,.pyc " skip bytecode files for filename completion
set suffixes-=.h " do not skip C header files for filename completion
set wrap " wrap long lines
set sidescroll=1 " smooth scroll if set nowrap. for slow terminals set to 0.
"set showbreak=>>>> " string to print before wrapped lines
" set backup " backup files before editing
" set backupdir=~/tmp,.,/tmp,/var/tmp " backup locations
set dir=~/tmp,.,/tmp,/var/tmp " swap file locations
set virtualedit=block " allow selection anywhere when in Visual block mode
set laststatus=2 " always show statusline 
set statusline=%n\ %1*%h%f%*\ %=%<[%3lL,%2cC]\ %2p%%\ 0x%02B%r%m
set ruler " show ruler, but only shown if laststatus is off
set rulerformat=%h%r%m%=%f " sane value in case laststatus is off
set nonumber " don't show line numbers
"set printoptions=number:y " put line numbers on hardcopy
" this turns on hlsearch, but clears the highlighting when Enter is hit
set wildmenu " show a menu of matches when doing completion
set hlsearch " highlight the current search pattern
set title " shows the current filename and path in the term title.
nnoremap <silent><CR> :nohlsearch<CR><CR> " in normal mode enter clears search highlight
if version >= 630
    set viminfo=!,%,'20,/100,:100,s100,n~/.viminfo " options for .viminfo
else
    set viminfo=!,%,'20,/100,:100,n~/.viminfo " options for .viminfo
endif
if version >= 700
    "set cusorline " highlight the line with the cursor
    set listchars=eol:$,tab:>-,trail:.,extends:>,precedes:<,nbsp:% " :help 'list
    set numberwidth=4 " width of line numbers
    set nofsync " improves performance -- let OS decide when to flush disk
else
    set listchars=eol:$,tab:>-,trail:.,extends:>,precedes:< " : help 'list
endif

" For the python.vim syntax by Dmitry Vasiliev.
let g:python_highlight_all=1

"
" tab settings
" sr=shiftround, et=expandtab, ts=tabstop, sw=shiftwidth
set sr et ts=4 sw=4 " default
autocmd FileType ruby set sr et ts=2 sw=2 " Ruby
autocmd FileType python set sr et ts=4 sw=4 " Python
autocmd FileType make set sr noexpandtab ts=4 sw=4 " Makefile
autocmd FileType man set sr noexpandtab ts=4 sw=4 " Man page (also used by psql to edit or view)
autocmd FileType calendar set sr noexpandtab ts=4 sw=4 " calendar(1) reminder service

" This was just too clever and never worked quite right.
" I still want something like this, so I keep it here in case
" I ever figure out a smarter way of doing this.
" use magictab
"inoremap <tab> <c-r>=MagicTabWrapper("forward")<cr>
"inoremap <s-tab> <c-r>=MagicTabWrapper("backward")<cr>

"
" maps
"

" map Q as @q (replay the recording named q). I always use q as my throw-away
" recording name, so I start recording with "qq" then reply the recording with
" "Q". I never found a use for interactive ex-mode so I don't miss the
" original definition of Q.
nnoremap Q @q

" get rid of most annoying typo: typing q: when I meant :q.
" You can still get to cmdline-window easily by typing <Ctrl-F> in
" command mode, so loosing q: is no loss.
map q: :q

" easy indentation in visual mode
" This keeps the visual selection active after indenting.
" Usually the visual selection is lost after you indent it.
vmap > >gv
vmap < <gv

" Use display movement with arrow keys for extra precision. Arrow keys will
" move up and down the next line in the display even if the line is wrapped.
" This is useful for navigating very long lines that you often find with
" automatically generated text such as HTML.
" This is not useful if you turn off wrap.
imap <up> <C-O>gk
imap <down> <C-O>gj
nmap <up> gk
nmap <down> gj
vmap <up> gk
vmap <down> gj

" This maps \y so that it will yank the visual selection, but also quote the
" regex metacharacters, so you can then paste into a search pattern. For
" example, use v to select some text. Press \y. Then start a search with /.
" Type CTRL-R" to insert the yanked selection. The last two mappings allow you
" to visual select an area and then search for other matches by typing * or #.
vmap <silent> <leader>y y:let @"=substitute(escape(@",'.$*[^\/~'),'\n','\\n','g')<CR>
vmap <silent> * y:let @/=substitute(escape(@",'.$*[^\/~'),'\n','\\n','g')<CR>n
vmap <silent> # y:let @/=substitute(escape(@",'.$*[^\/~'),'\n','\\n','g')<CR>N
vnoremap <silent> * :<C-U>
              \let old_reg=getreg('"')<bar>
              \let old_regmode=getregtype('"')<cr>
              \gvy/<C-R><C-R>=substitute(substitute(
              \escape(@", '\\/.*$^~[]' ), "\n$", "", ""),
              \"\n", '\\_[[:return:]]', "g")<cr><cr>
              \:call setreg('"', old_reg, old_regmode)<cr>
vnoremap <silent> # :<C-U>
              \let old_reg=getreg('"')<bar>
              \let old_regmode=getregtype('"')<cr>
              \gvy?<C-R><C-R>=substitute(substitute(
              \escape(@", '\\/.*$^~[]' ), "\n$", "", ""),
              \"\n", '\\_[[:return:]]', "g")<cr><cr>
              \:call setreg('"', old_reg, old_regmode)<cr>

" echo the date and time
"map <leader>d :echo strftime("%Y-%m-%d %H:%M:%S")<CR>

" refresh - redraw window
" <F5>
nnoremap <silent><F5> :redraw!<CR>

" This runs the current buffer in an X terminal that disappears after 5 minutes.
" This needs the env var $TERM set to xterm or some compatible X11 terminal.
" This does not save first!
" <F7> or \r
nnoremap <silent><F7> :call RunBufferInTerm()<CR>
nnoremap <silent><leader>r :call RunBufferInTerm()<CR>

" <F8> or \a
" yank all lines
nnoremap <silent><F8> gg"+yG
nnoremap <silent><leader>a gg"+yG
" <F10> or \n
" toggle line numbers
nnoremap <silent><F10> :set number!<CR>
nnoremap <silent><leader>n :set number!<CR>

"
" folding using the current /search/ pattern -- very handy!
"
" \z
" This folds every line that does not contain the search pattern.
" So the end result is that you only see lines with the pattern
" see vimtip #282 and vimtip #108
"map <silent><leader>z :set foldexpr=getline(v:lnum)!~@/ foldlevel=0 foldcolumn=0 foldmethod=expr<CR>
nnoremap <silent><leader>z :set foldexpr=(getline(v:lnum)=~@/)?\">1\":\"=\" foldlevel=0 foldcolumn=0 foldmethod=expr foldtext=getline(v:foldstart)<CR>
" space toggles the fold state under the cursor.
nnoremap <silent><space> :exe 'silent! normal! za'.(foldlevel('.')?'':'l')<CR>
" this folds all classes and functions -- mnemonic: think 'function fold'
nnoremap <silent>zff :set foldexpr=UniversalFoldExpression(v:lnum) foldmethod=expr foldlevel=0 foldcolumn=0 foldtext=getline(v:foldstart)<CR><CR>
function UniversalFoldExpression(lnum)
    if a:lnum == 1
        return ">1"
    endif
    return (getline(a:lnum)=~"^\\s*public function\\s\\|^\\s*private function\\s\\|^\\s*function\\s\\|^\\s*class\\s\\|^\\s*def\\s") ? ">1" : "="
endfunction

" jump to the last known position in a file
autocmd BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$") | exe "normal g'\"" | endif

" Add ruby-specific configurations for vim
autocmd BufNewFile,BufRead Gemfile set filetype=ruby
autocmd BufNewFile,BufRead Vagrantfile set filetype=ruby
autocmd BufNewFile,BufRead Berksfile set filetype=ruby

